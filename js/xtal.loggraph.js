/*

xtal.js Loggraph Viewer

JavaScript-based viewer for CCP4 loggraph plots.  Requires JQuery and D3.  This
does not actually parse the raw loggraph format, which dates from the golden
age of Fortran programming; instead, it reads a JSON representation, which can
be generated by iotbx.data_plots in CCTBX.

Exports:
	Loggraph

*/
var xtal = (function(module) {return module})(xtal||{});
xtal.loggraph = (function(module) {

function Loggraph (targetDivName, tables, graph_id, hide_interface) {
  this.graph_id = graph_id;
  var target = $(targetDivName);
  if (target == null) {
    throw Error("Can't find element " + targetDivName);
  }
  if (tables == null) {
    throw Error("No tables!");
  }
  if (tables.length == 0) {
    throw Error("Empty tables");
  }
  this.tables = tables;
  this.tableSelect = null;
  this.plotSelect = null;
  // set up HTML elements
  target.empty();
  if (! hide_interface) {
    var outer_div = $("<div/>").attr("class", "controls").attr("id",
      "loggraphControls");
    this.tableSelect = $("<select/>").attr("id", "tableSelect").attr("class",
      "wide");
    this.plotSelect = $("<select/>").attr("id", "plotSelect").attr("class",
      "wide");
    outer_div.append(
      $("<div/>").attr("class", "control-block").append(
        $("<div/>").attr("class", "control-item").html("<b>Table name:</b>"),
        $("<div/>").attr("class", "control-item").append(this.tableSelect)));
    outer_div.append(
      $("<div/>").attr("class", "control-block").append(
        $("<div/>").attr("class", "control-item").html("<b>Plot name:</b>"),
        $("<div/>").attr("class", "control-item").append(this.plotSelect)));
    target.append(outer_div);
    this.tableSelect.empty();
    this.plotSelect.empty();
    for (var i = 0; i < this.tables.length; i++)  {
      var table = this.tables[i];
      this.tableSelect.append($("<option/>").val(i).text(table.title));
    }
    // EVENTS
    var master = this;
    this.tableSelect.change(function () {
      var i_table = parseInt($(master.tableSelect).val());
      master.selectTable(i_table);
    });
    this.plotSelect.change(function () {
      var i_plot = parseInt($(master.plotSelect).val());
      master.selectPlot(i_plot);
    });
  } // END UI stuff
  this.plot = $("<div/>").attr("class", "loggraph-display").attr("id",
    "graph" + this.graph_id);
  target.append(this.plot);
  // populate controls

  this.selectTable = function (i_table) {
    var table = this.tables[i_table];
    if (this.plotSelect) {
      this.setPlots(i_table);
    }
    this.selectPlot(0);
  }

  this.setPlots = function (i_table) {
    this.plotSelect.empty();
    var table = this.tables[i_table];
    for (var j = 0; j < table.graph_names.length; j++) {
      this.plotSelect.append($("<option/>").val(j).text(table.graph_names[j]));
    }
    this.plotSelect.width(this.plotSelect.parent().width());
  }

  // draw a plot
  this.selectPlot = function (i_plot) {
    this.plot.empty();
    var i_table = null;
    if (this.tableSelect) {
      i_table = parseInt($(this.tableSelect).val());
    } else {
      i_table = 0;
    }
    var table = this.tables[i_table];
    var data = table.data;
    var margin = {top: 20, right: 20, bottom: 30, left: 50},
      width = 800 - margin.left - margin.right,
      height = 600 - margin.top - margin.bottom;
    var columns = table.graph_columns[i_plot];
    var plot_name = table.graph_names[i_plot];
    var x = d3.scale.linear().range([0, width]);
    var y = d3.scale.linear().range([height, 0]);
    var color = d3.scale.category10();
    var xAxis = d3.svg.axis().scale(x).orient("bottom");
    var yAxis = d3.svg.axis().scale(y).orient("left");
    var x_series = table.data[columns[0]];
    x.domain(d3.extent(x_series));
    var y_label = "";
    if (table.graph_labels) {
      y_label = table.graph_labels[i];
    } else if (columns.length == 2) {
      y_label = table.column_labels[columns[1]];
    }
    if (!this.plot) {
      throw Error("Plot not initialized");
    }
    if (! hide_interface) {
      this.plot.append($("<p/>").attr("class", "plotTitle").text(plot_name));
    }
    select_tag = "#graph" + this.graph_id;
    var svg = d3.select(select_tag).append("svg")
      .attr("width", width + margin.left + margin.right)
      .attr("height", height + margin.top + margin.bottom)
      .append("g")
        .attr("transform", "translate(" + margin.left + "," + margin.top + ")");
    svg.append("g")
      .attr("class", "x axis")
      .attr("transform", "translate(0," + height + ")")
      .call(xAxis);
    svg.append("g")
      .attr("class", "y axis")
      .call(yAxis)
      .append("text")
        .attr("transform", "rotate(-90)")
        .attr("y", 6)
        .attr("dy", ".71em")
        .style("text-anchor", "end")
        .text(y_label);
    var series_ids = [];
    var all_y_series = [];
    for (var j = 1; j < columns.length; j++) {
      series_ids.push(j);
      var y_series = data[columns[j]];
      for (var k = 0; k < y_series.length; k++) {
        all_y_series.push(y_series[k]);
      }
    }
    color.domain(series_ids);
    y.domain([ d3.min(all_y_series), d3.max(all_y_series) ]);
    var line = d3.svg.line()
      .interpolate("linear")
      .x(function(d) { return x(d.xval); })
      .y(function(d) { return y(d.yval); });
    var ktmp = [];
    for (var k = 0; k < data[columns[0]].length; k++) ktmp.push(k);
    var series = color.domain().map(function(j) {
      return {
        id: j,
        values: ktmp.map(function(k) {
          return { xval: data[columns[0]][k], yval: data[columns[j]][k] };
        })
      };
    });
    // guess optimal legend position - this makes certain risky assumptions
    // about data points!
    var offset = 0;
    var y_end_max = 0, y_end_min = height;
    for (var j = 1; j < columns.length; j++) {
      y_end = y(data[columns[j]][ktmp.length - 1]);
      y_end_max = Math.max(y_end, y_end_max);
      y_end_min = Math.min(y_end, y_end_min);
    }
    if (y_end_min < 60) {
      offset = Math.min(height - y_end_min, height - 100);
    }
    // draw lines and legend
    for (var j = 1; j < columns.length; j++) {
      console.log("drawing line");
      var column = svg.selectAll(".column")
        .data(series)
        .enter().append("g")
        .attr("class", "graph_series");
      column.append("path")
        .attr("class", "line")
        .attr("d", function(d) { return line(d.values); })
        .style("stroke", function(d) { return color(d.id); });
      var legend = svg.selectAll(".legend")
        .data(color.domain())
        .enter().append("g")
          .attr("class", "legend")
          .attr("transform", function(d, i) {
            return "translate(0," + (offset + (i * 20)) + ")";
          });
      legend.append("rect")
        .attr("x", width - 18)
        .attr("width", 12)
        .attr("height", 2)
        .style("fill", color);
      legend.append("text")
        .attr("x", width - 24)
        .attr("y", 0)
        .attr("dy", ".35em")
        .style("text-anchor", "end")
        .text(function (k) { return table.column_labels[columns[k]] });
    }
  }

  // EVENTS
  // now draw the first available plot
  this.selectTable(0);
}

// Exports
return {
	'Loggraph': Loggraph
}
})(xtal);
